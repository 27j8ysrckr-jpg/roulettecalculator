<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analisi Roulette Avanzata</title>
    <style>
        /* --- CSS Globale (Sfondo Verde) --- */
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            margin: 0; 
            padding: 20px; 
            /* Verde da tavolo da gioco */
            background-color: #006400; 
            color: #f0f0f0; 
        }
        .container { 
            max-width: 1200px; 
            margin: auto; 
            /* Sfondo semi-trasparente */
            background-color: rgba(0, 0, 0, 0.4); 
            padding: 30px; 
            border-radius: 12px; 
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7); 
            border: 4px solid gold; /* Bordo decorativo */
        }
        h1 { color: #f0ad4e; text-align: center; margin-bottom: 30px; } /* Giallo/Arancio per i titoli */

        /* --- Input e Controlli --- */
        .controls { 
            display: flex; gap: 20px; margin-bottom: 25px; align-items: center; 
            background-color: rgba(0, 0, 0, 0.4); 
            padding: 15px; border-radius: 8px; 
            border: 1px solid #4a4a4a;
        }
        .input-group { flex-grow: 1; display: flex; flex-direction: column; }
        label { margin-bottom: 5px; font-weight: bold; color: #fff; } /* Testo bianco */
        #drawnNumber { 
            padding: 10px; border: 2px solid #555; border-radius: 6px; 
            background-color: white; color: #333; font-size: 1.1em; text-align: center; 
        }
        .buttons button { padding: 10px 20px; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; transition: background-color 0.3s; }
        #elaborateBtn { background-color: #5cb85c; color: white; }
        #elaborateBtn:hover { background-color: #449d44; }
        #resetBtn { background-color: #d9534f; color: white; } /* Rosso di reset sul tavolo */
        #resetBtn:hover { background-color: #c9302c; }

        /* --- Main Layout --- */
        .main-content { display: flex; gap: 25px; }
        .wheel-area { flex: 2; min-width: 350px; }
        .stats-area { flex: 1; min-width: 300px; }
        
        /* --- Roulette Wheel Visual --- */
        .wheel-container { text-align: center; position: relative; margin-top: 20px; }
        .wheel-svg { max-width: 100%; height: auto; }
        .wheel-svg text { font-size: 12px; fill: #f0f0f0; user-select: none; }
        .wheel-svg .segment { transition: fill 0.3s, stroke 0.3s; cursor: default; }

        /* Stili per l'evidenziazione dinamica */
        .segment.drawn-1 { fill: #f0ad4e !important; stroke: #fff; stroke-width: 2px; } /* Ultimo estratto: Arancio evidenziato */
        .segment.drawn-2 { fill: #5bc0de !important; stroke: #fff; stroke-width: 1.5px; } /* Penultimo: Azzurro */
        .segment.drawn-3 { fill: #5cb85c !important; stroke: #fff; stroke-width: 1px; } /* Terzultimo: Verde Chiaro */
        
        .segment.terminal { stroke: #d9534f; stroke-width: 3px; } /* Terminali: Rosso Bord√≤ */
        .segment.opposite { stroke: #d9534f; stroke-dasharray: 4; stroke-width: 3px; } /* Terminali Opposti: Rosso Bord√≤ Tratteggiato */
        .segment.zero { fill: #1c7430; } /* Zero (Verde scuro) */
        .segment.red { fill: #8b0000; } /* Rosso */
        .segment.black { fill: #000000; } /* Nero */

        /* --- Statistiche Tabella --- */
        #statisticsTable { width: 100%; border-collapse: collapse; margin-top: 10px; }
        #statisticsTable th, #statisticsTable td { padding: 12px; text-align: left; border-bottom: 1px solid #4a4a4a; }
        #statisticsTable th { background-color: #004d00; color: #f0ad4e; font-weight: bold; } /* Sfondo Testa di Tabella: Verde pi√π scuro, Testo Arancio */
        #statisticsTable td { background-color: rgba(0, 0, 0, 0.4); } /* Sfondo Celle Trasparente */
        .alert-info { padding: 10px; background-color: #f0ad4e; color: #333; border-radius: 4px; margin-top: 15px; text-align: center; font-weight: bold; }

    </style>
</head>
<body>

<div class="container">
    <h1>Analisi Numeri Terminali Roulette üéØ</h1>
    
    <div class="controls">
        <div class="input-group">
            <label for="drawnNumber">Inserisci il Numero Estratto:</label>
            <input type="number" id="drawnNumber" placeholder="0 - 36" min="0" max="36">
        </div>
        <div class="buttons">
            <button id="elaborateBtn" onclick="processDrawnNumber()">ELABORA DATI</button>
            <button id="resetBtn" onclick="resetApp()">RESET / NUOVA SERIE</button>
        </div>
    </div>

    <div class="main-content">
        <div class="wheel-area">
            <h2>Visualizzazione Ruota Europea üåê</h2>
            <div class="wheel-container" id="wheelContainer">
                </div>
        </div>

        <div class="stats-area">
            <h2>Statistiche (Rif. Ultimo Estratto) üìà</h2>
            <div id="statisticsOutput">
                <p>Nessun dato elaborato. Inserisci il primo numero estratto.</p>
            </div>
        </div>
    </div>
</div>

<script>
    // --- 1. DATI e SETUP ---

    // Ordine della ruota Europea (0 in senso orario, come fornito precedentemente)
    const ROULETTE_ORDER = [0, 32, 15, 19, 4, 21, 2, 25, 17, 34, 6, 27, 13, 36, 11, 30, 8, 23, 10, 5, 24, 16, 33, 1, 20, 14, 31, 9, 22, 18, 29, 7, 28, 12, 35, 3, 26];
    const TOTAL_NUMBERS = ROULETTE_ORDER.length; // 37

    // Colori della Ruota
    const ROULETTE_COLORS = {
        '0': 'zero',
        '32': 'red', '15': 'black', '19': 'red', '4': 'black', '21': 'red', '2': 'black', '25': 'red', '17': 'black', '34': 'red', '6': 'black', '27': 'red', '13': 'black', '36': 'red', '11': 'black', '30': 'red', '8': 'black', '23': 'red', '10': 'black', '5': 'red', '24': 'black', '16': 'red', '33': 'black', '1': 'red', '20': 'black', '14': 'red', '31': 'black', '9': 'red', '22': 'black', '18': 'red', '29': 'black', '7': 'red', '28': 'black', '12': 'red', '35': 'black', '3': 'red', '26': 'black'
    };

    // La tabella dei Terminali fornita dall'utente (convertita in oggetto JS)
    const TERMINALS_TABLE = {
        0: [7], 1: [8], 2: [7, 9], 3: [8], 4: [11], 5: [10, 12], 6: [11], 7: [2, 14], 8: [1, 3, 13, 15], 9: [2, 14],
        10: [5, 17], 11: [4, 6, 16, 18], 12: [5, 17], 13: [8, 20], 14: [7, 9, 19, 21], 15: [8, 20], 16: [11, 23],
        17: [10, 12, 22, 24], 18: [11, 23], 19: [14, 26], 20: [13, 15, 25, 27], 21: [14, 26], 22: [17, 29],
        23: [16, 18, 30, 28], 24: [17, 29], 25: [20, 32], 26: [19, 21, 31, 33], 27: [20, 32], 28: [23, 35],
        29: [22, 24, 34, 36], 30: [23, 35], 31: [26], 32: [25, 27], 33: [26], 34: [29], 35: [28, 30], 36: [29]
    };

    let drawnNumbers = []; // Memoria degli estratti (max 3 per visualizzazione)
    let lastReferenceNum = null;

    // --- 2. FUNZIONI DI LOGICA ---

    // Trova l'indice di un numero sulla ruota
    function getIndex(num) {
        return ROULETTE_ORDER.indexOf(num);
    }

    // Calcola la distanza minima sulla ruota
    function getWheelDistance(num1, num2) {
        const index1 = getIndex(num1);
        const index2 = getIndex(num2);
        if (index1 === -1 || index2 === -1) return -1;
        
        let distance = Math.abs(index1 - index2);
        return Math.min(distance, TOTAL_NUMBERS - distance);
    }

    // Calcola i Terminali Opposti per un dato numero estratto
    function calculateOpposites(refNum, terminals) {
        const opposites = [];
        const refIndex = getIndex(refNum);
        
        for (const T_num of terminals) {
            const T_index = getIndex(T_num);
            if (T_index === -1) continue;

            let CW_dist = (T_index - refIndex + TOTAL_NUMBERS) % TOTAL_NUMBERS;
            let CCW_dist = (refIndex - T_index + TOTAL_NUMBERS) % TOTAL_NUMBERS;

            let dist_to_use;
            let opposite_index;
            
            if (CW_dist <= CCW_dist) {
                // Terminale pi√π vicino CW, Opposto √® CCW alla stessa distanza
                dist_to_use = CW_dist;
                opposite_index = (refIndex - dist_to_use + TOTAL_NUMBERS) % TOTAL_NUMBERS;
            } else {
                // Terminale pi√π vicino CCW, Opposto √® CW alla stessa distanza
                dist_to_use = CCW_dist;
                opposite_index = (refIndex + dist_to_use) % TOTAL_NUMBERS;
            }
            
            opposites.push(ROULETTE_ORDER[opposite_index]);
        }
        return opposites;
    }

    // --- 3. FUNZIONI DI INTERFACCIA E PROCESSO ---

    function processDrawnNumber() {
        const inputElement = document.getElementById('drawnNumber');
        const numStr = inputElement.value;
        const newNum = parseInt(numStr);

        if (isNaN(newNum) || newNum < 0 || newNum > 36) {
            alert('Per favore, inserisci un numero valido tra 0 e 36.');
            return;
        }

        // 1. Aggiorna la memoria degli estratti (solo gli ultimi 3)
        if (drawnNumbers[0] !== newNum) { // Evita duplicati consecutivi
            drawnNumbers.unshift(newNum);
            if (drawnNumbers.length > 3) {
                drawnNumbers.pop();
            }
        }
        
        lastReferenceNum = drawnNumbers[0];
        
        // 2. Esegui il calcolo principale (solo se abbiamo almeno 2 numeri per le distanze)
        if (drawnNumbers.length >= 2) {
            const prevRefNum = drawnNumbers[1]; // Il numero che genera i Terminali e Opposti
            const currentNum = drawnNumbers[0]; // Il numero di cui calcoliamo le distanze

            // Terminali e Opposti sono GENERATI dal penultimo estratto (E1 di riferimento)
            const T = TERMINALS_TABLE[prevRefNum] || [];
            const TO = calculateOpposites(prevRefNum, T);

            updateStatistics(currentNum, prevRefNum, T, TO);
            updateWheelVisualization(currentNum, T, TO);
            
        } else {
            // Primo numero estratto
            const T = TERMINALS_TABLE[lastReferenceNum] || [];
            const TO = calculateOpposites(lastReferenceNum, T);
            document.getElementById('statisticsOutput').innerHTML = 
                '<div class="alert-info">Primo Numero Estratto: ' + lastReferenceNum + '. Inserisci il secondo numero per calcolare le distanze.</div>' +
                generateSimpleStatsTable(lastReferenceNum, T, TO);
            updateWheelVisualization(lastReferenceNum, T, TO);
        }

        // Pulisci l'input per il prossimo inserimento
        inputElement.value = '';
    }

    function generateSimpleStatsTable(refNum, T, TO) {
        let html = '<table id="statisticsTable"><thead><tr><th>Tipo</th><th>Numeri</th><th>Riferimento</th></tr></thead><tbody>';
        
        html += '<tr><td>Terminali (T)</td><td>' + T.join(', ') + '</td><td>Generati dal ' + refNum + '</td></tr>';
        html += '<tr><td>Terminali Opposti (TO)</td><td>' + TO.join(', ') + '</td><td>Opposti al ' + refNum + '</td></tr>';

        html += '</tbody></table>';
        return html;
    }

    function updateStatistics(currentNum, refNum, T, TO) {
        let html = '<h4>Analisi Distanze per E2: ' + currentNum + ' (Rif. E1: ' + refNum + ')</h4>';
        
        // Tabella riassuntiva
        html += generateSimpleStatsTable(refNum, T, TO);

        // Tabella Distanze
        html += '<h4>Distanze sulla Ruota:</h4>';
        html += '<table id="statisticsTable"><thead><tr><th>Numero</th><th>Tipo</th><th>Distanza (Posizioni)</th></tr></thead><tbody>';

        // Distanze dai Terminali
        for (const t of T) {
            const dist = getWheelDistance(currentNum, t);
            html += `<tr><td>${t}</td><td>Terminali (T)</td><td>${dist}</td></tr>`;
        }

        // Distanze dai Terminali Opposti
        for (const t of TO) {
            const dist = getWheelDistance(currentNum, t);
            html += `<tr><td>${t}</td><td>Terminali Opposti (TO)</td><td>${dist}</td></tr>`;
        }
        
        html += '</tbody></table>';

        document.getElementById('statisticsOutput').innerHTML = html;
    }

    function resetApp() {
        drawnNumbers = [];
        lastReferenceNum = null;
        document.getElementById('drawnNumber').value = '';
        document.getElementById('statisticsOutput').innerHTML = '<p>Nessun dato elaborato. Inserisci il primo numero estratto.</p>';
        generateWheelSVG(); // Rigenera la ruota base
    }

    // --- 4. FUNZIONI GRAFICHE (SVG) ---

    function generateWheelSVG(highlightCurrent = null, T = [], TO = []) {
        const container = document.getElementById('wheelContainer');
        const radius = 150;
        const center = 160;
        const angleStep = 360 / TOTAL_NUMBERS;
        let svgContent = '';
        
        // Inizia SVG
        svgContent += `<svg class="wheel-svg" viewBox="0 0 ${center * 2} ${center * 2}" xmlns="http://www.w3.org/2000/svg">`;

        // Crea 37 segmenti
        for (let i = 0; i < TOTAL_NUMBERS; i++) {
            const num = ROULETTE_ORDER[i];
            const startAngle = i * angleStep;
            const endAngle = (i + 1) * angleStep;
            
            const startX = center + radius * Math.cos((startAngle - 90) * Math.PI / 180);
            const startY = center + radius * Math.sin((startAngle - 90) * Math.PI / 180);
            const endX = center + radius * Math.cos((endAngle - 90) * Math.PI / 180);
            const endY = center + radius * Math.sin((endAngle - 90) * Math.PI / 180);

            const pathData = [
                `M ${center},${center}`,
                `L ${startX},${startY}`,
                `A ${radius},${radius} 0 0,1 ${endX},${endY}`,
                `Z`
            ].join(' ');

            // Classi per colori e evidenziazioni
            let classes = ROULETTE_COLORS[num] + ' segment';
            if (num === drawnNumbers[0] && drawnNumbers.length >= 1) classes += ' drawn-1';
            if (num === drawnNumbers[1] && drawnNumbers.length >= 2) classes += ' drawn-2';
            if (num === drawnNumbers[2] && drawnNumbers.length >= 3) classes += ' drawn-3';
            if (T.includes(num)) classes += ' terminal';
            if (TO.includes(num)) classes += ' opposite';
            
            // Disegna il segmento
            svgContent += `<path d="${pathData}" class="${classes}" data-num="${num}"/>`;

            // Calcola la posizione per il testo
            const textAngle = startAngle + (angleStep / 2);
            const textRadius = radius * 0.8;
            const textX = center + textRadius * Math.cos((textAngle - 90) * Math.PI / 180);
            const textY = center + textRadius * Math.sin((textAngle - 90) * Math.PI / 180);
            
            // Disegna il numero
            svgContent += `<text x="${textX}" y="${textY}" dominant-baseline="middle" text-anchor="middle">${num}</text>`;
        }

        // Cerchio centrale
        svgContent += `<circle cx="${center}" cy="${center}" r="30" fill="#3a3a3a" />`;
        svgContent += `<text x="${center}" y="${center}" dominant-baseline="middle" text-anchor="middle" font-weight="bold" fill="#fff" font-size="14px">RUOTA</text>`;

        // Chiudi SVG
        svgContent += `</svg>`;
        container.innerHTML = svgContent;
    }
    
    // Aggiorna la visualizzazione della ruota
    function updateWheelVisualization(currentRef, T, TO) {
        // Se c'√® un secondo numero estratto, i terminali e opposti si riferiscono al penultimo
        // Se c'√® solo un numero, i terminali e opposti si riferiscono a quel numero
        if (drawnNumbers.length > 1) {
            const referenceNum = drawnNumbers[1];
            T = TERMINALS_TABLE[referenceNum] || [];
            TO = calculateOpposites(referenceNum, T);
        } else if (drawnNumbers.length === 1) {
            T = TERMINALS_TABLE[drawnNumbers[0]] || [];
            TO = calculateOpposites(drawnNumbers[0], T);
        }
        
        generateWheelSVG(currentRef, T, TO);
    }
    
    // Avvia l'interfaccia all'apertura
    window.onload = function() {
        generateWheelSVG();
    };
</script>

</body>
</html>